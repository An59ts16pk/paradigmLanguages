# Бинарный поиск
# Предположим, что мы хотим найти элемент в массиве (получить
# его индекс). Мы можем это сделать просто перебрав все элементы.
# Но что, если массив уже отсортирован? В этом случае можно
# использовать бинарный поиск. Принцип прост: сначала берём
# элемент находящийся посередине и сравниваем с тем, который мы
# хотим найти. Если центральный элемент больше нашего,
# рассматриваем массив слева от центрального, а если больше -
# справа и повторяем так до тех пор, пока не найдем наш элемент.
# Ваша задача
# Написать программу на любом языке в любой парадигме для
# бинарного поиска. На вход подаётся целочисленный массив и
# число. На выходе - индекс элемента или -1, в случае если искомого
# элемента нет в массиве.
# Использована процедурная парадигма - binary_search и не большой код
# структурной парадигмы для вывода результата

def binary_search(array, find_elem):
    start_index = 0
    end_index = len(array) - 1
    while start_index <= end_index:
        middle_index = start_index + (end_index - start_index) // 2
        if array[middle_index] == find_elem:
            return middle_index
        elif array[middle_index] < find_elem:
            start_index = middle_index + 1
        else:
            end_index = middle_index - 1
    return -1
    

listArr = [1, 3, 4, 6, 7, 8, 10, 13, 14]
number = 4

result = binary_search(listArr, number)
print(result)

if result == -1:
    print(f'\nЭлемента {number} в массиве нет.')
else:
    print(f'\nИндекс элемента {number} в массиве = {result}')